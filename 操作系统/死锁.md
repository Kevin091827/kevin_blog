# 什么是死锁？

进程之间都在等待对方手里的资源，并且对自己手里的资源不释放，导致进程之间发生阻塞，无法向前推进，也就是进程不能实现同步

类似java中的死锁

![](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1568000677589&di=e7108192ca39525379bad5ec398df592&imgtype=0&src=http%3A%2F%2Fimg2018.cnblogs.com%2Fblog%2F735767%2F201907%2F735767-20190726115151827-1482763577.png)

# 死锁产生的必要条件

死锁产生的必要条件有四个，缺一不可：

- 互斥条件，只有对互斥使用的资源的争抢才会导致死锁
- 不可剥夺条件，进程所获得的资源在未使用完之前不能被其他进程夺走，只能主动释放
- 请求和保持条件，进程已经获得了至少一个资源，但是他又提出了新的资源请求，而这个请求的资源又被其他进程占有
- 循环等待条件，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路。

# 处理策略

针对死锁的处理策略主要有两种：

- 破坏死锁产生的四个条件之一
- 银行家算法

## 1.破坏死锁产生条件

**破坏互斥条件**

采用SPOOLING技术使进程独占资源编程进程共享资源

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190909090807340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTkyMjI4OQ==,size_16,color_FFFFFF,t_70)


**破坏不可剥夺条件**

- 当某进程请求的资源长时间得不到满足时，必须立即释放该进程原来保持的所有资源，以后需要再申请资源

- 由操作系统协助，强行剥夺

**破坏请求和保持条件**

采用静态分配法，程序运行后一次申请所需的全部资源

**破坏循环等待条件**

采用资源有序分配法，破坏"环路"条件。

## 2.避免死锁 -- 银行家算法

在介绍银行家算法前，先了解这样一个概念

- 安全序列

    安全序列是指如果系统按照这种序列分配资源，则每个进程都能顺利完成，只要能找出这样一个安全序列，系统就处于安全状态，安全状态下一定不会发生死锁

而银行家算法的核心就是在资源分配之前先判断这次分配会不会导致系统进入不安全状态




## 死锁检测

系统由若干类资源构成
一类资源称为一个资源类
每个资源类包含若干个同种资源，称为资源实例
结点的表示法：

资源类（资源的不同类型） 用方框表示
资源实例（存在于每个资源类中） ，用方框中的黑圆点（圈）表示 

![](https://img-blog.csdn.net/20180723120457186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hbmlhY3h4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

进程 用圆圈中加进程名表示 

![](https://img-blog.csdn.net/20180723120513960?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hbmlhY3h4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

边集中各边的含义：

分配边 资源实例–>进程 的一条有向边 <rj,pi>

申请边 进程–>资源类 的一条有向边 <pi,rj>

![](https://img-blog.csdn.net/20180723120725267?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21hbmlhY3h4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

如果所有边能消除，则一定不会发生死锁

不能完全消除所有边，则发生了死锁

## 死锁解除
  
重要的是以最小的代价解除死锁，恢复系统运行。方法如下：

- 撤消所有的死锁进程（撤销进程法）
- 连续撤消死锁进程直至不再存在死锁（撤销进程法）
- 连续剥夺资源直到不再存在死锁（资源剥夺法）
- 把每个死锁进程备份到前面定义的某个检查点，并重新启动所有进程（进程回退法）



