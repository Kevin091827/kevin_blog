# 一，什么是原子操作？

原子操作就是不可中断的一个或一系列的操作

# 如何实现原子操作？

首先处理器是能自动保证基本的内存操作的原子性，处理器自动保证从系统内存中读取或者写入一个字节是原子的，当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。但是对于复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度，跨多个缓存行和跨页表的访问。

## 复杂内存操作实现原子性

### 1.总线锁定

当处理器A在处理共享内存I，那么处理器A就会使用总线锁来保证原子性，会在总线中发送一个LOCK#信号，其他处理器的请求将会被阻塞，那么处理器A就可以独占共享内存I

总线锁定把CPU和内存之间的通信锁住了，这使得锁定期间，其它处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大

### 2.缓存锁定

内存区域如果被缓存在处理器的缓存行中，并且在LOCK操作期间被锁定，那么当他执行锁操作回写到内存时，处理器不在总线上发出lock信号，而是修改内部的内存地址，并允许他的缓存一致性机制来保证操作的原子性（缓存一致性机制会阻止同时修改两个以上处理器缓存的内存区域的数据，当其他处理器回写已被锁定的缓存行数据时，会使缓存行无效）

不允许使用缓存锁定：

- 有些处理器不支持缓存锁定

- 当操作的数据不能缓存在处理器内部或者操作多个缓存行时

### 3.CAS

关于java中如何使用cas保证原子操作可以看[java中的CAS](https://blog.csdn.net/weixin_41922289/article/details/94415610)


**CAS导致三个问题**

- ABA问题。 

     因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A－>B－>A就会变成1A－>2B－>3A。从Java1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该饮用和该标志的值设置为给定的更新值。
     ```java
     public boolean compareAndSet｛        
        V    expectedReference，        //预期引用        
        V    newReference，                //更新后的引用       
        int    expectedStamp                 //预期标志       
        int    newStamp                         //更新后的标志
     ｝     
     ```
- 循环时间长开销大。

    自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令，使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空，从而提高CPU的执行效率。  
    
-   只能保证一个共享变量的原子操作。

    当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个巧取的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j＝a，合并一下ij＝2a，然后用CAS来操作ij＝2a，然后用CAS来操作ij。从JDK1.5开始提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。

